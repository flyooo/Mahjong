2017.6.6开始
考虑按牌种生成牌堆，挑选算分牌型就可决定地方牌种。

CMJ所有功能函数约75个

//节点信息  
struct stPAI  
{  
    int     m_Type;             //牌类型  
    int     m_Value;            //牌字  
  
}  
;  
  
//吃牌顺  
struct stCHI                      
{  
    int     m_Type;             //牌类型  
    int     m_Value1;           //牌字  
    int     m_Value2;           //牌字  
    int     m_Value3;           //牌字  
}  
;  

//胡牌信息  
struct stGoodInfo  
{  
    char    m_GoodName[100];            //胡牌术语  
    int     m_GoodValue;                //胡牌番数  
} 

//扩展  
struct stPAIEx  
{  
    stPAI   m_NewPai;                       //起的新牌  
    int     m_PaiNum;                       //剩余牌数  
    bool    m_IsHZ;                         //是否黄庄  
}  
;  


//麻将管理和麻将玩家对应管理类CMJManage和玩法CMJ,麻将管理类实现三部份，初始牌、洗牌、取牌。


原参考程序三连张检测 if(iValue1 == (iValue2-1)&&iValue2 == (iValue3-1))return true; 这个要求先对三个值排序，
改为三个值的和求除3平均数和模3余0,首要条件模3余0,然后比较三个参都要小于等于平均数+1，满足二个条件的组合为连续数。

import itertools
for i in itertools.product('123456789', repeat = 3):
	print i

for i in itertools.combinations('123456789', 3):
	print i

for i in itertools.combinations_with_replacement('ABCD', 2):
	print i
测试组合复筛选出三连张
import itertools

d = [ [int(i[0]),int(i[1]),int(i[2])] for i in itertools.combinations('123456789', 3)]
print d
def checkABC(a,b,c):
    h=a+b+c
    if not (h%3):
        k=h/3+1
	if(a<=k and b<=k and c <=k):
		print a,b,c

for l in d:
    checkABC(l[0],l[1],l[2])

牌的检测顺序:胡、杠、碰、吃，胡牌先检测大胡子，像青一色、七小对，再检测四个、三个、对子。
上手检测牌，先从上手花色开始，先检三个再检二个最后检吃牌， 别人打牌只要检测胡牌或杠或碰。

参考牌型检测，先从牌型需要数量开始。如一色双龙会，一种花色的两个老少副，5为将牌， 例中从1235789比较对子，不满足条件返回假。
改为单色14张牌，排除4、6牌， 和一色双龙会和值。

长沙麻将胡子计算
七对、清一色、碰碰胡、将将胡、全求人、平胡、
板板胡、四喜、六六顺、缺一色、天胡 （这些都是起手检测）


将将胡，所有牌值都是2、5、8，检测方法，模3余2 。板板胡检测相反，没有一张将牌。
for i in range(1,9):
    if i%3==2:
	print i

七小对检测，如果先按花色分组再排序，再比较四个或二个，7小对不能吃牌，如果占位排序，108张牌的占位数很大。实际每个用户14张牌，遍列14张牌
把相同的放在一起。这样最后只要检测是不是七对就可以，可以用map结构

清一色和缺一色相似，碰碰胡，六六顺都是检测三张相同，四喜四张相同，七小对是检测对子。全求人是手上只有一张牌。

例中使用临时吃牌数组，存储吃牌组合，方便输出,吃牌检测,以已有牌数2、3、4、5、6构成ab、abc、abbc、abbbc、abbbbc形，比较上手牌加减1和2等于已有牌值，就表示再连。
改为，以上手牌为中心，向左向右查找可以连接的牌 [12(3)45]，向左-1如果满足再-1，不满足向右+1查找，满足条件再+1查找，不满足结束。查找到的数小于3不合格，大于等于3输出组合。

检测杠和碰，条件杠牌数>=3 ，碰牌数>=2，记录同张数

如何检测胡牌，四方子带一对满足胡牌,刻子在检测胡牌，拆为三加一，一般最好是拆为顺子和对子，对子做将牌。长沙麻将除去风牌箭牌，只留筒条万字，对三色遍列，检测方法一样。

例中检测听牌，AddPai加入新牌并排序，先确定花色以牌数来确认检测方法，2、3、5、6、8、9、11、12、14种方法，其中加入了对将牌、刻子和顺子的检测。
修改胡牌检测方法：遍列花色，再先检牌数,合格的牌是将、顺子、刻子，牌数是2、3或组合（5、6、8、9、11、12）,像1、4、7、10、13这种牌数拆2或3总是多一张是不符合胡牌要求（胡牌要求一对将，其它都是三张一组）,所有牌的组合达到四组一对将，才能胡牌。
像3、6、9、12不能拆出对将，拆2就多一张散牌，而2、5、8、11必需包对将，否则直接返回假，形像[34555]可以拆345也可以是555，拆555剩34不能做将，5张牌做将只能在旁边，小胡必需2、5、8做将，除5外可在中间外，2、8都会在旁边。
像3、6、9、12先进行排序，然后3个组去检测，要么是顺子，要么是刻子，其它返回假。最复杂的是2、5、8、11，牌数2直接检测将牌对子，其它先进行排序，

麻将胡牌检测主要牌形,ABC、AAA、AABBCC，基它是这些牌形的混合型式，因为1-9头尾不能再接其它牌，所以头尾优先排列,并且牌数大于6才会出现混合牌型（如：AABBBCCCD）。除去对将，总牌数12张，所以AABBBCCCD后面还有三张牌，顺子或是刻子，牌形也可以从右向左，
所以牌数大于6优先检测两头是否出现AABB牌形。
方法二、AABBCC和AAABBBCCC展开为ABC顺子，可以顺子优前剩下检测刻子，用标注索引排除法。1-9十个数，每个数4张，整体40，不需要排序，用一个64位整数就能全部表达，每个数移动4位，9×4=36 代表9第36位开始取数。
def test():
    y=0
    # lst=[random.randint(1,9) for a in range(13)]
    lst=[3, 5, 6, 8, 8, 6, 6, 8, 8, 4, 9, 5, 1]
    print lst
    for i in lst:
        x=y<<1
        x=1<<i*4|x
        y|=15<<i*4&x
    s= bin(y)
    print len(s),s


go整合排序
var arr = [13]uint64{1, 5, 6, 8, 8, 6, 7, 8, 8, 4, 2, 5, 3}
func sorti(arr *[13]uint64) uint64 {
	var y uint64 = 0
	for _, i := range arr {
		j := y >> (i * 4) & 15
		k := j<<1 + 1
		y = y | (k << (i * 4))
	}
	return y
}

检测顺子，输出123,456而567没有输出，这个检测方法需要来回检测，完成检测不好界定。
func combination(i uint64) {
	var l, n int64 = 0, 0
	var s string = ""
	for j := i; j > 0; {
		if j&1 == 1 {
			l++
			c := strconv.FormatInt(n, 10)
			s = s + c
			if l%3 == 0 {
				fmt.Println(s)
				l, s = 0, ""
			}
		} else {
			l, s = 0, ""
		}
		j = j >> 4
		n++
	}
}
直接以牌形组合的数值来判断是否合格。首先找到最小值，取最小值段和后两段，三段每段4位共12位，可能组合是ABC,AABBCC,AAABBBCCC,AAAABBBBCCCC这些是合格组合，任意组合值都不会一样。
测试组合输出值
def combv():

测试分3,6,9,12无将和5,8,11,14有将

计算i为当前段的值，i=3不需要将时只要简单的取aaa,如果是需要将牌时，aaabcde_一直延伸，找到断点，或大于1的位置，再看组合优先级。
最后如果出现的将对超过1对，或是剩下的牌不能组成顺子，但和对子连接，就需要回退组合。
除非确定是对子，不然都优先以顺子和刻子组合，如果出现边张，也能找相连的牌很快重排。
当22234567,先取222后面剩67就会出错,需要重排. 重排有三种方法，
一、回退找到222取两个做将再继续向后排;二、标记222出错时直接从队列中删除两个22再重排一次;三、从大到小再排一次，或只末完成倒排序;
第二种简单，但程序需要修改参数重入，第一种前如出现AABBCC回退实现麻烦，所以优先考虑第三种，反向排序。

如果先找将牌，将牌在AA,AAA,AAAA牌形中,
aaaabbbbcccc, aaaabbbbccccdd, aaaabbbcccd, aaaabbcc, aaaabc / aaabcd, aaabc, aaa / aa
查找顺序：对子、杠、刻子，刻子和杠都需要连接其它，杠可以折成(2,2)(3,1)但在找将时只折(2,2)同样刻子折为(2，1)，刻子折分需要顺子相连，所以先查找对子和暗杠确认将牌，不能确认的由后面顺子中回退检测。

首为暗杠时，要么（2,2）或么(3,1)，不开杠胡牌，为了拆分做将。所以(2,2)为首先。

测试牌型 
[1,1,1,1,2,2,2,2,3,3,3,3,5,5]	aaaabbbbcccc
[1,1,1,1,2,2,3,3,5,6,7]		aaaabbcc
[2,2,2,2,3,3,4,4,5,6,7]		aaaabc
[2,2,2,3,4,7,8,9]	aaabc_
[1,2,2,2,3,4,5,6]

在牌墙中使用1-9、11-19、21-29分别代表三种花色的牌，这样方便查将将胡


进牌的顺子、刻子、杠需要分别记录，其中刻子还有可能开杠，为了简化，顺子只记录第一个数，如123只记录1，另外每类吃牌都有花色，如果用1~9就需要按花色分成数组保存，如果按1-29就可以直接保存。


在对1-29数子分组中，出现错误，跑一次不会出错，跑多次出错。问题出在分片清空操作
ply.tile[0] = ply.tile[0][:0]
ply.tile[1] = ply.tile[0][:0]	后面的ply.tile[0]改为对应的tile[1]

单机电脑打牌
出牌顺序，边张1,9牌，前后不靠单张牌，散张先于将牌单张, 清一色优先清除其它花色，七小对优先清除将牌，将将胡优先清对子。
跟臭张，打下手一样的花色和牌，打自已不要和别人都不要的牌。

如何让电脑打牌，需要确定吃牌打牌优先级策。
先从上手牌确定胡牌类型,优先做大胡，最后平胡，一般的吃牌的优先级：暗杠、刻子、顺子、对子、连张、隔张、将牌、单张。其中单张中的1,9连张优先级最低
根据胡牌类型，调整吃牌优先级，定将将胡时吃牌时将牌优先级最高，定清一色吃牌时同色优先级最高，定七小对吃牌时对子优先级最高，碰碰时和一般优先级一致。大胡不要258做将，所以258和其它单片优先级一样。平胡需要258做将，将牌优先级低于'连张'高于'隔张'
更高一级要求，在听牌之前，牌型也可以根据后进牌做出调整，
确认胡牌类型：将将胡JJH,清一色QYS,七小对QXD,碰碰胡PPH,平胡
建一个关于优先级的结构，level，命名2AA,AAA,ABC,AA,AB,AC,J,A,C（J为将牌，A为单张，C为单边）级别优先级用数字表示，0为最低级别，一直往上加，当一个数即是刻子还是顺子的连张，优先级别是两个优先相加，这样可以保证这种数子不会在开始打出。
启手时把各花色的最低级别上报，以1-29数值为键，优先级为值，吃牌后如果检测为真就检测胡牌，否则把当前花色最低优先级上报，然后把所有花色上报最低优前级排序，取出最低级别打出。最先级最终是落到每张牌上，相同的牌相一张，原型可以先不考虑牌型，按一般优先级来处理，单牌(2,b,c)级别都是零，AC隔张不加优先级，也就是AC先排除不做连张，而是单张。
计算方法
AB连张A和B优先级都加1,AA优先级加2,AAA优先级加3,AAAA优先级加4, 像ABC,A=1、B=2、C=1,
直接按顺序递增2AA/6 AAA/5 ABC/4 AA/3 AB/2 AC/1 A/0, 像AB, A=2 B=2, ABC中拆成AB BC, A=2 C=2 B=4剩下AC，A和C各加1，最终是A=3 B=4 C=3,这种组合已经包含了ABC结构，因为优先级最终要落实到每张牌上，选AB,AC计算。AA在于AB AC，等于小于ABC连张，最终选对子还是顺子大，可以在组合胡牌类型决定AAA刻子5大于ABC顺子。AAAA杠6最大。
调整优先级数值
AAAA/6 AAA/5 AA/4 AB/3 AC/2 J/1 A/0, 像ABC优先级A=5 B=6 C=5, 像ABCDE,A=5 B=6 E=5 D=6 C=10 这个问题来了，多连牌优先级比刻子和杠还要高。
实际情况，打清一色时多连张确实比刻子和杠高，先提是不同色。一般情况下：优先级数值设计两个的优先组最低级是所有一个优先级数值和，三个是二个的数值和。除了组合，还要考虑组合的牌数，AAAA优先级通常要比4个连张牌优先级高。另外234个A和顺子连接时，优先级是叠加还是要加入其它机制。
实际决定是杠刻需不需要和顺子交叉，如何交叉,牌型AABBCC、AAABC等能拆分的情况很多，先简单做叠加，AABC这种，实际ABC连张，多出一个A可以打掉，保证AA的优先级就可以了。

原型优先级: AAAA/6 AAA/5  AA/3 AB/2 AC/1 A/0
4A 3A 2A 都 是确定当单个牌优先级，再取ABC叠加优先级，以第一个计算出来的数为最低优先级，遇到更低的交换，同级不变，这是因为数据从左到右排序，前面的是靠最左的，也就是边张，所以同值中优先级实际更底。
func grading() uint {...}

可以定义结构保存花色和牌点还有优先级，实始化的时候把所有牌的优先级全部算一遍，吃牌时只要重新算一下牌的加入的牌对现有牌的优先级影响。
type mjgrad struct{
tile	int
card	int
level	int
}

现有三色牌 23456 123466 66 程序吃牌打牌Chi 13 Da 6，这个结果有出入，56是顺连，而14,16是隔张，但因国前面还有12,13连14这样14的权重比56高。
一般情况是对的，但1234这个是四连张，最终多出一张牌，但如果直接降级，顺子的级别比可能会比连张低。关键问题是如何挑出四连张中一张做单张。

第二有牌 3445 3344566 66 Chi 16 Da 26，这个牌把一对26打掉了一个，而保留了3445中的4，连张权重比对子高，问题是组成顺子后多出单张4，
对子组合顺子后，剩下单张要降级,正常打出4后就正好听牌。

通过花色牌数，可以确定是否有单张，如果不是将牌，四连张就先出一张，而不是拆其它牌的连张或是顺子，并且单张会出现在两个花色中。可以比较决定先出那个花色的牌。这个有两个大的策略，一是按牌连接形成的优先级，二是顺子刻子满足胡牌条件的优先，多出的牌降优先级处理,单将比单张对将比普通对子权重。
所以将2345的四连张，在无将情况下，可调将胡牌，权重不降返升。对子如果不是将，可以拆开处理。

重新调整权重: AAA/6 ABC/5 JJ/5 AA/4 AB/3 AC/2 J/1 A/0
单牌 A/0 J/1
双牌 JJ/5 AA/4 AB/3 AC/2
三张 AAA/6 ABC/5 这些是满足胡牌条件的牌型，还包括JJ是对将，单牌权重AAA最高，胡牌优先级相同，决定性因素是胡牌类型。
AAAA单牌权重最高，但胡牌检测只要3A，另外多出一个A，如果要听牌时，应该考虑开杠或补张。打牌是尽可能满足胡牌条件也要满足吃牌条件。
AB AC各有优先级，当ABC连张时，权重是否要叠加，如何叠加。
如ABD牌型，A权重3,D权重2,B中包含AB和BD两种连接，BD就是AC型的权重是2所以B的权重是2+3=5，如果是ABCD中B的权重是8，B是单张不是对子，权重却比顺子和对子高，这就是权重叠加的问题。但AAB中A的权重和B一样，那吃牌是会被像连张一样拆开打掉。所以AAB交差时AA需要叠加权重。
但如果是AABC型，就多一个A，A的权重不加反降，同样ABCD中AD中必须有一个降权到连张级别，比单张高比连张低，可以等于将牌权重。
如果是ABCDE，DE的权重应该比AB型连张权重高。或者直接以ABCDE连张来定权重，ABCDE在ABC权重上+1,ABCD选AD之一权重降2
ABCDE排除前面ABC顺子DE为连张加左顺子，DE权重比AB连张权重要高，但如果A或E中任何一个为连张（1,9）DE为AC权重。
ABCD型AD为将，并且牌中无将，AD不降权，非则降权到比单张高比连张低。

   










